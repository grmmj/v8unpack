# Сборка и распаковка

## Распаковка файла 1С
из командной строки:

    v8unpack.exe -E d:/sample.cf d:/unpack

из python:

```python
import v8unpack

if __name__ == '__main__':
    v8unpack.extract('d:/sample.cf', 'd:/unpack')
```

## Сборка исходников

из командной строки:

    v8unpack.exe -B d:/unpack d:/repacked.cf

из python:

```python
import v8unpack

if __name__ == '__main__':
    v8unpack.build('d:/unpack', 'd:/repacked.cf')
```

Параметр1 - Путь до папки с исходниками, может быть указан относительный путь.
Параметр2 - Путь до бинарного файла, включая его имя

## Обновление индекса

из командной строки:

    v8unpack.exe -I src --index index.json --core core

из python:

```python
import v8unpack

if __name__ == '__main__':
    v8unpack.update_index('d:/unpack', index)
```

## Дополнительные именованные параметры сборки и разборки

Дополнительные параметры могут быть указаны через одноименные ключи как при запуске из командной строки,
так и при запуске из python

### version

#### Внешние обработки
При разборке не используется. 

При сборке указывает под какую платформу собирается обработка: допустимые значения 801, 802, 803

#### Расширения конфигурации
При разборке указывает каким значением затереть версию режима совместимости - может быть полезно,
чтобы не прыгала при работе с различными версия. 

При сборке указывает какое значение версии режима совместимости установить. Заполняется по формату
XYYZZ, например 8.3.6 = 80306 

#### Конфигурации
Пока не используется, работает только со значением по умолчанию.


### temp
Путь до временной папки, если указан то будет использована указанная папка, а временные файлы
не будут удалены по завершении операции. Папка в любом случае очищается перед началом распаковки.


### core

Относительный путь к папке с общими исходникам.  

Данный параметр имеет значение только в режиме обновления файла индекса. 

Если он указан, то пути новых общих файлов будут заполняться относительно этой папки, а не 
папки с исходниками. 


# Переиспользование

Первичной целью проекта была сборка разных продуктов 1С из одних и тех же исходников. 
Общий для разных продуктов программный код и объекты метаданных (далее общие файлы)
предполагается разместить в отдельных репозиториях (git submodules). 


## Переиспользование кода

Разбиение кода на несколько файлов делается с помощью областей имеющих в названии
ключевое слово include: 

    #Область include_[путь до файла]
    #КонецОбласти 

Для версий 82 и 81 все директивы компилятора автоматически экранируются 
в комментарий //v8unpack {#директива...}. ВАЖНО. Есть маленькое допущение сильно
упрощающее жизнь - код не может начинаться с директивы (замена происходит 
по \n# - просто отступите строку в начале кода)

    //v8unpack #Область include_[путь до файла]
    //v8unpack #КонецОбласти 


При разборке модуля код внутри include области вырезается и сохраняется в
отдельный файл, при сборке происходит обратная процедура.


"Путь до файла" - это путь относительно родительского каталога папки распаковки 
(корня репозитория при рекомендованной структуре), где в качестве разделителя 
используется символ подчеркивания.

Например, в нижеследующем примере рядом с папкой сборки будет создана папка "core",а 
в ней папка "form3" с файлом "test.1с" содержащий весь код внутри области. В исходном 
файле формы останется только описание области.

    #Область include_core_form3_test
    ПримерКода = 1;
    #КонецОбласти

Если область include содержат другие вложенные области include они будут так же вынесены в 
отдельные папки. Путь рассчитывается так же как и для области верхнего уровня.
 
Области include могут содержать обычные области.

Пустое значение в имени include области трактуется как переход к папке верхнего уровня.

## Переиспользование макетов и форм


На последнем шаге разбора утилита копирует файлы по указанным папкам - соответственно
после редактирования файла нужно разобрать чтобы файлы легли на нужные месте. 

```json

  {
    "ExternalDataProcessor.1c": "core\\ExternalDataProcessor.1c",
    "ExternalDataProcessor.data83.json": "core\\ExternalDataProcessor.data83.json",
    "ExternalDataProcessor.json": "core\\ExternalDataProcessor.json",
    "Form": {
      "API.1c": "core\\Form\\API.1c",
      "API.form83.json": "core\\Form\\API.form83.json"
    }
  }
 ```
Чтобы не набивать руками есть генератор оглавления, который добавляет в имеющийся
файл все чего там нет.

    v8unpack.exe -I src --index index.json -core core
    
параметры 
* src - папка с исходниками
* index.json - путь до файла индекса 
* core - каталог с общими модулями по умолчанию, если указан в index.json значения 
  заполнятся если симметричными путями начинающимися с него, а если не указать 
  заполнит пустыми значениями

Важно! Все пути указанные в индексе должны не должны весть внутрь папаки с исходниками.

# Обновление

Версия модуля строится по шаблону {мажор}.{минор}.{патч}

Смена номера мажорной или минорной версии говорит об обратной несовместимости.

Собирать исходники разобранные утилитой с другой мажорной+минорной версией нельзя!

Порядок обновления:
1. Соберите бинарник старой версией.
2. Обновите утилиту.
3. Разберите бинарник новой версией.
4. Закоммитьте изменения.


# Рекомендации

* указывайте расширение имени файла в последнем слове комментария к метаданным хранящим
бинарные данные (макеты, общие картинки и т.п.), тогда после разборки вы будете иметь 
файлы с правильным расширением.


# Разработка расширений конфигурации

## Методика работы по сборка расширений под разные конфигурации 1С и разные их версии.

Входные условия: у нас есть расширение, которое сделано для нескольких конфигураций и
мы поддерживаем его для различных версий этих конфигураций.

Проблема: конфигурации и платформа периодически меняется, меняется и само расширение.

1. Нам необходимо как то легко при изменении платформы или конфигурации об этом узнавать,
и при необходимости вносить изменение в расширение.
2. Изменгения вносимые при изменении платформы или версии конфигурации должны быть 
минимальны и в иделале затрагивать только соответсвующий объект метаданных в исходниках
(без содания копии всего приложения).
3. При изменении расширения выпускать обносвленную версию для всех поддерживаемых платформ
и версий конфигураций.

На текущей момент (конец 2021) нет готового решения для данной задачи. Наше решение
призвано несколько облегчить жизнь разработчику.  


Предполагается следующий концепт:
1. Все версии расширения под все конфигурации будут храниться в одном репозитории.
1.1. Под каждую версию режима совместимости, где не достаточно просто смены номера версии,
 будет создаваться отдельная версия и папка с исходниками.
1.2. В этой папке исходники хранятся в разрезе конфигураций. У каждого файла исходника есть суфикс с
номером версии конфигурации начиная с которой он применяется. 
1.3. При сборке компилятору указывается номер версии режима совместимости и номер версии конфигурации - 
компилятор если не находит исходник с указанной версией конфигурации берет ближайшую в меньшую сторону.
1.4. При разборке папка исходников поностью не очищается, в ней удаляются только файлы с суфиксом по 
номеру текущей версии конфигурации. 
Компилятору указывается номер текущей версии конфигурации. 
Если есть файл исходника, с той же версией, он будет заменен. 
Если его нет компилятор сравнит файл исходника с ближайшей в меньшую сторну версией и если они 
отличаются, создаст файл в папке с текущей версией конфигурации.
1.5. При разметке областей кода, правило п.1.4 распространяется на файлы внутри папки с исходниками,
общие файлы лежащие вне папки исходников берутся как есть без поиска по поверсиям. 

## Отслеживание изменеий конфигуркции
Автоматизации пока нет, руками прокликиваем все объекты и обновляем то что поменялось,
если в итоге решаем что хотим выпостить версию, то разбираем расширение указав компилятору
номер версии конфигурации, который он будет использовать в качестве суфикса. 

Затем удаляем из папки с исходниками все не изменившиеся файлы. Возможно когда нибуть это 
сделает сам компилятор.

Таким образом 


```
    > bin - папка куда будут собираться бинарники расширения
      {Название расширения}.{Код конфигурации}.{Версия совместимости}.cfe
    > core - submodule для общих с другими продуктами ресурсов
    > base - общие файлы этого расширения, структура идентична струтуре расширения
    > src
        > {код конфигурации}- папка содержит файлы актуальные для этой конфигурации 1С
    > cmd
        > {код конфигурации}- папка содержит коммандные файлы для версий этой конфигурации 1С
            build.x_y_z_b.cmd        - запускалка сборки версии 
            extract.x_y_z_b.cmd      - запускалка разборки версии
            update_index.x_y_z_b.cmd - формирования и обновления индекса
            index.x_y_z_b.json       - словарь общих файлов
            build.cmd              - запускалка сборки всех версий
            extract.cmd            - запускалка разборки версий
    build.cmd        - запускалка сборки всех расширений
    extract.cmd      - запускалка разборки всех расширений

   
```
* -x_y_z_b - версия конфигурации 1C как есть, точки заменены на подчеркивание

При такой структуре содержимое index.json будет симметричным для разных версий.

При сборке целевая версия режима совместимости задается через параметр version сборщика.

Версия режима совместимости указывается в формате 1C (XYYZZ), например 8.3.6 = 80306.
Указанная версия добавляется как есть. Если указать версию при разборке, она заменит
версию указанную в исходниках, это может быть полезно чтобы при коммитах версия не 
скакала.

Рекомендуется встраиваться в интерфейс исключительно кодом.

При необходимости изменить программный код под особенности версии он выносится в область.
Область пощается в base на самую старую версию с которой он работает. Под текущую версию создается
новая папка XYYZZZBBB в ней 

Параллелить общую сборку смысла особо нет, т.к. сама сборка использует все ресурсы.
Общую запускал проще сделать на python путем автоматического обхода папок. Кроме этого
при таком подходе можно создать один пул процессов на всю сборку, это сэкономит чуток 
времени. 


