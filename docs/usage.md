# Сборка и распаковка

## Распаковка файла 1С
из командной строки:

    v8unpack.exe -E d:/sample.cf d:/unpack

из python:

```python
import v8unpack

if __name__ == '__main__':
    v8unpack.extract('d:/sample.cf', 'd:/unpack')
```

## Сборка исходников

из командной строки:

    v8unpack.exe -B d:/unpack d:/repacked.cf

из python:

```python
import v8unpack

if __name__ == '__main__':
    v8unpack.build('d:/unpack', 'd:/repacked.cf')
```

Параметр1 - Путь до папки с исходниками, может быть указан относительный путь.
Параметр2 - Путь до бинарного файла, включая его имя

## Обновление индекса

из командной строки:

    v8unpack.exe -I src --index index.json --core core

из python:

```python
import v8unpack

if __name__ == '__main__':
    v8unpack.update_index('d:/unpack', index)
```

## Дополнительные именованные параметры сборки и разборки

Дополнительные параметры могут быть указаны через одноименные ключи как при запуске из командной строки,
так и при запуске из python

### version

#### Внешние обработки
При разборке не используется. 

При сборке указывает под какую платформу собирается обработка: допустимые значения 801, 802, 803

#### Расширения конфигурации
При разборке указывает каким значением затереть версию режима совместимости - может быть полезно,
чтобы не прыгала при работе с различными версия. 

При сборке указывает какое значение версии режима совместимости установить. Заполняется по формату
XYYZZ, например 8.3.6 = 80306 

#### Конфигурации
Пока не используется, работает только со значением по умолчанию.


### temp
Путь до временной папки, если указан то будет использована указанная папка, а временные файлы
не будут удалены по завершении операции. Папка в любом случае очищается перед началом распаковки.


### core

Относительный путь к папке с общими исходникам.  

Данный параметр имеет значение только в режиме обновления файла индекса. 

Если он указан, то пути новых общих файлов будут заполняться относительно этой папки, а не 
папки с исходниками. 


# Переиспользование

Первичной целью проекта была сборка разных продуктов 1С из одних и тех же исходников. 
Общий для разных продуктов программный код и объекты метаданных (далее общие файлы)
предполагается разместить в отдельных репозиториях (git submodules). 


## Переиспользование кода

Разбиение кода на несколько файлов делается с помощью областей имеющих в названии
ключевое слово include: 

    #Область include_[путь до файла]
    #КонецОбласти 

Для версий 82 и 81 все директивы компилятора автоматически экранируются 
в комментарий //v8unpack {#директива...}. ВАЖНО. Есть маленькое допущение сильно
упрощающее жизнь - код не может начинаться с директивы (замена происходит 
по \n# - просто отступите строку в начале кода)

    //v8unpack #Область include_[путь до файла]
    //v8unpack #КонецОбласти 


При разборке модуля код внутри include области вырезается и сохраняется в
отдельный файл, при сборке происходит обратная процедура.


"Путь до файла" - это путь относительно родительского каталога папки распаковки 
(корня репозитория при рекомендованной структуре), где в качестве разделителя 
используется символ подчеркивания.

Например, в нижеследующем примере рядом с папкой сборки будет создана папка "core",а 
в ней папка "form3" с файлом "test.1с" содержащий весь код внутри области. В исходном 
файле формы останется только описание области.

    #Область include_core_form3_test
    ПримерКода = 1;
    #КонецОбласти

Если область include содержат другие вложенные области include они будут так же вынесены в 
отдельные папки. Путь рассчитывается так же как и для области верхнего уровня.
 
Области include могут содержать обычные области.

Пустое значение в имени include области трактуется как переход к папке верхнего уровня.

## Переиспользование макетов и форм


На последнем шаге разбора утилита копирует файлы по указанным папкам - соответственно
после редактирования файла нужно разобрать чтобы файлы легли на нужные месте. 

```json

  {
    "ExternalDataProcessor.1c": "core\\ExternalDataProcessor.1c",
    "ExternalDataProcessor.data83.json": "core\\ExternalDataProcessor.data83.json",
    "ExternalDataProcessor.json": "core\\ExternalDataProcessor.json",
    "Form": {
      "API.1c": "core\\Form\\API.1c",
      "API.form83.json": "core\\Form\\API.form83.json"
    }
  }
 ```
Чтобы не набивать руками есть генератор оглавления, который добавляет в имеющийся
файл все чего там нет.

    v8unpack.exe -I src --index index.json -core core
    
параметры 
* src - папка с исходниками
* index.json - путь до файла индекса 
* core - каталог с общими модулями по умолчанию, если указан в index.json значения 
  заполнятся если симметричными путями начинающимися с него, а если не указать 
  заполнит пустыми значениями

Важно! Все пути указанные в индексе должны не должны весть внутрь папаки с исходниками.

# Обновление

Версия модуля строится по шаблону {мажор}.{минор}.{патч}

Смена номера мажорной или минорной версии говорит об обратной несовместимости.

Собирать исходники разобранные утилитой с другой мажорной+минорной версией нельзя!

Порядок обновления:
1. Соберите бинарник старой версией.
2. Обновите утилиту.
3. Разберите бинарник новой версией.
4. Закоммитьте изменения.


# Рекомендации

* указывайте расширение имени файла в последнем слове комментария к метаданным хранящим
бинарные данные (макеты, общие картинки и т.п.), тогда после разборки вы будете иметь 
файлы с правильным расширением.

* Установите плагин подстветки синтаксиса 1С для вашего текстового редактора.

Через меню Notepad++ Синтаксисы >> Польз.Синтаксис >> Открыть папку синтаксисов...
- откроется папка с синтасисами, скопируйте файл туда 
[файл настроек подсветки для Notepad++](highlight_notepad.xml)и перезапустите Notepad++.

# Разработка расширений конфигурации

## Методика работы по сборка расширений под разные конфигурации 1С и разные их версии.

Входные условия: у нас есть расширение, которое сделано для нескольких конфигураций и
мы поддерживаем его для различных версий этих конфигураций.

Проблема: конфигурации и платформа периодически меняется, меняется и само расширение.

Задачи:
1. При изменении платформы или конфигурации легко узнавать о необходимости вносить 
изменения в расширение.

2. Обеспечить минимальную зависимость основного функционала от версии платформы и
конфигурации. Особенности версий конфигурации отделены от основного функционала 
расширения.

3. При изменении расширения автоматически выпускать обносвленную версию для всех 
поддерживаемых версий конфигураций.

Поскольку на конец 2021 мы не нашли способов решений этих задач, предлагается решить
эти задачи при помощи saby v8unpack следующим образом:

1. Все версии расширения под все конфигурации хранятся в одном репозитории.

2. Под каждую конфигурацию в корне папки src создается отдельная папка.

3. У каждого файла исходника в имя файла добавляется суффикс с номером версии конфигурации. 
Данный суффикс говорит о том, начиная с какой версии конфигурации можно брать данный исходник. 

4. При разборке расширения компилятору в параметре descent указывается номер версии конфигурации 
под которую сделано расширение. Компилятор при сохранении файла исходника проверяет отличается 
ли данный файл от файла предыдущей версии, если не отличается то файл не выгружается, если 
отличается или предыдущей версии вообще нет, то файл с номером текущей версии в суффиксе. 

5. При сборке поведение аналогичное, если файл нужной версии есть берется он, если нет берется 
файл от ближайшей в меньшую сторону версии. 

6. Предполагается, что общие доработки делаются на минимальной версии конфигурации, а особенности 
конкретных версий платформы или конфигурации вынесены в отдельные файлы при помощи областей
или index json.

7.Суфиксы добавляются только к файлам внутри папки с исходниками, включая файлы областей кода. 
В файлы вне папки исходников, и все файлы указанные в index суфикс не добавляется.


Ограничения: Предполагается, что у конфигурации четырехзначная нумерация версий, каждый 
разряд номера версии занимает не более 3 знаков (не встречали 4 знака, не стали делать 
чтобы имена файлов были по проще). Суффикс в имени файла указывается в виде числа, 
где каждый разряд, кроме первого, дополняется ведущими нулями. Суффиксы 
формируются автоматически при разборе конфигурации.


## Отслеживание изменеий конфигурации
Автоматизации пока нет, руками прокликиваем все объекты и обновляем то что поменялось,
если в итоге решаем что хотим выпустить версию, то разбираем расширение указав компилятору
номер версии конфигурации, который он будет использовать в качестве суфикса. 

## Рекоммендуемая технология работя
Для каждой конфигурации создаем эталонную тестовую базу для тестирования расширения конфигурации.

При появлении новой версии конфигурации создаем копию тестовой базы и обновляем её до новой версии.

Проверяем на работоспособность нашего расширения, если никаких доработок не требуется, удаляем её.

Если требуются доработки делаем их. Если доработки делаются по конкретно эту версию и не могут быть
применены к ранним версиям, то оставляем эту базу и разбираем исходники с указанием этой 
версии конфигурации в параметре descent - таким образом в исходниках фиксируются отличия данной версии.
Создаются коммандные файлы для сборки / разборки этой версии конфигурации.


```
   > 1C
      > Platform
         > {XYYZZZ} - версия платформы
     > TestBase
         > {Код конфигурации} - БУХ3, УТ10 и т.п.
            > {XYYYZZZ} - версия конфигурации
               файлы конфигурации
     > {Название расширения}
        > bin - папка куда будут собираться бинарники расширения
          {Название расширения}.{Код конфигурации}.{Версия конфигурации с которой можно применять}.cfe
        > core - submodule для общих с другими продуктами ресурсов
        > base - общие файлы этого расширения, структура идентична струтуре расширения
        > src
            > {код конфигурации}- папка содержит файлы актуальные для этой конфигурации 1С
        > cmd
            > {код конфигурации}- папка содержит коммандные файлы для версий этой конфигурации 1С
                build.XYYYZZZ.cmd        - запускалка сборки версии 
                extract.XYYYZZZ.cmd      - запускалка разборки версии
                update_index.XYYYZZZ.cmd - формирования и обновления индекса
                index.XYYYZZZ.json       - словарь общих файлов
                build.cmd              - запускалка сборки всех версий
                extract.cmd            - запускалка разборки версий
        build.cmd        - запускалка сборки всех расширений
        extract.cmd      - запускалка разборки всех расширений

```

Предполагается, что мы сохраяем для тестиу нас есть эталонные тестовые базы всех версий конфигураций и платформ
в которых имеются различия и для которых мы поддерживаем

пока откатываем... 


* -XYYYZZZ - версия конфигурации 1C, первые три разряда с ведущими нулями (чертвертый разряд
игнорируется, т.к. не должно быть существенных изменений в каком то билде. 3 знака, потому что
 не встречали четырехзначных номеров. Первый разряд может быть любой длинны.

При сборке целевая версия режима совместимости задается через параметр version сборщика.

Версия режима совместимости указывается в формате 1C (XYYZZ), например 8.3.6 = 80306.
Указанная версия добавляется как есть. Если указать версию при разборке, она заменит
версию указанную в исходниках, это может быть полезно чтобы при коммитах версия не 
скакала.



### Распаковка файла расширения 1С
из командной строки:

    v8unpack.exe -E d:/sample.cf d:/unpack --index index.json --descent 4100200


### Сборка расширения из исходников

из командной строки:

    v8unpack.exe -B d:/unpack d:/repacked.cf --index index.json --descent 4100200 --version 803012



